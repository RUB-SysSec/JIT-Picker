From 5b00264555223d3aed3a72f063980a8685025a9b Mon Sep 17 00:00:00 2001
From: Lukas Bernhard <15350042+bernhl@users.noreply.github.com>
Date: Sat, 9 Apr 2022 12:37:43 +0200
Subject: [PATCH 1/5] Improve differential testing capabilities


diff --git a/js/src/builtin/TestingFunctions.cpp b/js/src/builtin/TestingFunctions.cpp
index 35d20ccc880c..e7885664f317 100644
--- a/js/src/builtin/TestingFunctions.cpp
+++ b/js/src/builtin/TestingFunctions.cpp
@@ -8046,7 +8046,7 @@ static bool FdLibM_Pow(JSContext* cx, unsigned argc, Value* vp) {
 }
 
 // clang-format off
-static const JSFunctionSpecWithHelp TestingFunctions[] = {
+static const JSFunctionSpecWithHelp TestingFunctions_differential[] = {
     JS_FN_HELP("gc", ::GC, 0, 0,
 "gc([obj] | 'zone' [, ('shrinking' | 'last-ditch') ])",
 "  Run the garbage collector.\n"
@@ -8056,6 +8056,46 @@ static const JSFunctionSpecWithHelp TestingFunctions[] = {
 "  The second parameter is optional and may be 'shrinking' to perform a\n"
 "  shrinking GC or 'last-ditch' for a shrinking, last-ditch GC."),
 
+    JS_FN_HELP("serialize", testingFunc_serialize, 1, 0,
+"serialize(data, [transferables, [policy]])",
+"  Serialize 'data' using JS_WriteStructuredClone. Returns a structured\n"
+"  clone buffer object. 'policy' may be an options hash. Valid keys:\n"
+"    'SharedArrayBuffer' - either 'allow' or 'deny' (the default)\n"
+"      to specify whether SharedArrayBuffers may be serialized.\n"
+"    'scope' - SameProcess, DifferentProcess, or\n"
+"      DifferentProcessForIndexedDB. Determines how some values will be\n"
+"      serialized. Clone buffers may only be deserialized with a compatible\n"
+"      scope. NOTE - For DifferentProcess/DifferentProcessForIndexedDB,\n"
+"      must also set SharedArrayBuffer:'deny' if data contains any shared memory\n"
+"      object."),
+
+    JS_FN_HELP("deserialize", Deserialize, 1, 0,
+"deserialize(clonebuffer[, opts])",
+"  Deserialize data generated by serialize. 'opts' may be an options hash.\n"
+"  Valid keys:\n"
+"    'SharedArrayBuffer' - either 'allow' or 'deny' (the default)\n"
+"      to specify whether SharedArrayBuffers may be serialized.\n"
+"    'scope', which limits the clone buffers that are considered\n"
+"  valid. Allowed values: ''SameProcess', 'DifferentProcess',\n"
+"  and 'DifferentProcessForIndexedDB'. So for example, a\n"
+"  DifferentProcessForIndexedDB clone buffer may be deserialized in any scope, but\n"
+"  a SameProcess clone buffer cannot be deserialized in a\n"
+"  DifferentProcess scope."),
+
+    JS_INLINABLE_FN_HELP("bailout", testingFunc_bailout, 0, 0, TestBailout,
+"bailout()",
+"  Force a bailout out of ionmonkey (if running in ionmonkey)."),
+
+  JS_FN_HELP("trialInline", TrialInline, 0, 0,
+"trialInline()",
+"  Perform trial-inlining for the caller's frame if it's a BaselineFrame."),
+
+    JS_FS_HELP_END
+};
+// clang-format on
+
+// clang-format off
+static const JSFunctionSpecWithHelp TestingFunctions[] = {
     JS_FN_HELP("minorgc", ::MinorGC, 0, 0,
 "minorgc([aboutToOverflow])",
 "  Run a minor collector on the Nursery. When aboutToOverflow is true, marks\n"
@@ -8096,10 +8136,6 @@ static const JSFunctionSpecWithHelp TestingFunctions[] = {
 "isLcovEnabled()",
 "  Return true if JS LCov support is enabled."),
 
-  JS_FN_HELP("trialInline", TrialInline, 0, 0,
-"trialInline()",
-"  Perform trial-inlining for the caller's frame if it's a BaselineFrame."),
-
     JS_FN_HELP("hasChild", HasChild, 0, 0,
 "hasChild(parent, child)",
 "  Return true if |child| is a child of |parent|, as determined by a call to\n"
@@ -8648,10 +8684,6 @@ JS_FOR_WASM_FEATURES(WASM_FEATURE, WASM_FEATURE, WASM_FEATURE)
 "getAllocationMetadata(obj)",
 "  Get the metadata for an object."),
 
-    JS_INLINABLE_FN_HELP("bailout", testingFunc_bailout, 0, 0, TestBailout,
-"bailout()",
-"  Force a bailout out of ionmonkey (if running in ionmonkey)."),
-
     JS_FN_HELP("bailAfter", testingFunc_bailAfter, 1, 0,
 "bailAfter(number)",
 "  Start a counter to bail once after passing the given amount of possible bailout positions in\n"
@@ -8685,32 +8717,6 @@ JS_FOR_WASM_FEATURES(WASM_FEATURE, WASM_FEATURE, WASM_FEATURE)
 "  are valuable and should be generally enabled, however they can be very expensive for large\n"
 "  (wasm) programs."),
 
-    JS_FN_HELP("serialize", testingFunc_serialize, 1, 0,
-"serialize(data, [transferables, [policy]])",
-"  Serialize 'data' using JS_WriteStructuredClone. Returns a structured\n"
-"  clone buffer object. 'policy' may be an options hash. Valid keys:\n"
-"    'SharedArrayBuffer' - either 'allow' or 'deny' (the default)\n"
-"      to specify whether SharedArrayBuffers may be serialized.\n"
-"    'scope' - SameProcess, DifferentProcess, or\n"
-"      DifferentProcessForIndexedDB. Determines how some values will be\n"
-"      serialized. Clone buffers may only be deserialized with a compatible\n"
-"      scope. NOTE - For DifferentProcess/DifferentProcessForIndexedDB,\n"
-"      must also set SharedArrayBuffer:'deny' if data contains any shared memory\n"
-"      object."),
-
-    JS_FN_HELP("deserialize", Deserialize, 1, 0,
-"deserialize(clonebuffer[, opts])",
-"  Deserialize data generated by serialize. 'opts' may be an options hash.\n"
-"  Valid keys:\n"
-"    'SharedArrayBuffer' - either 'allow' or 'deny' (the default)\n"
-"      to specify whether SharedArrayBuffers may be serialized.\n"
-"    'scope', which limits the clone buffers that are considered\n"
-"  valid. Allowed values: ''SameProcess', 'DifferentProcess',\n"
-"  and 'DifferentProcessForIndexedDB'. So for example, a\n"
-"  DifferentProcessForIndexedDB clone buffer may be deserialized in any scope, but\n"
-"  a SameProcess clone buffer cannot be deserialized in a\n"
-"  DifferentProcess scope."),
-
     JS_FN_HELP("detachArrayBuffer", DetachArrayBuffer, 1, 0,
 "detachArrayBuffer(buffer)",
 "  Detach the given ArrayBuffer object from its memory, i.e. as if it\n"
@@ -9190,5 +9196,14 @@ bool js::DefineTestingFunctions(JSContext* cx, HandleObject obj,
     return false;
   }
 
-  return JS_DefineFunctionsWithHelp(cx, obj, TestingFunctions);
+  if (!JS_DefineFunctionsWithHelp(cx, obj, TestingFunctions_differential)) {
+    return false;
+  }
+
+  if (!js::SupportDifferentialTesting()) {
+    return JS_DefineFunctionsWithHelp(cx, obj, TestingFunctions);
+  }
+  else {
+    return true;
+  }
 }
diff --git a/js/src/jit/BaselineCacheIRCompiler.cpp b/js/src/jit/BaselineCacheIRCompiler.cpp
index a2b945962c72..3a20d7ed8213 100644
--- a/js/src/jit/BaselineCacheIRCompiler.cpp
+++ b/js/src/jit/BaselineCacheIRCompiler.cpp
@@ -1275,6 +1275,10 @@ bool BaselineCacheIRCompiler::emitMathRandomResult(uint32_t rngOffset) {
   masm.randomDouble(scratch1, scratchFloat, scratch2,
                     output.valueReg().toRegister64());
 
+  if (js::SupportDifferentialTesting()) {
+    masm.zeroDouble(scratchFloat);
+  }
+
   masm.boxDouble(scratchFloat, output.valueReg(), scratchFloat);
   return true;
 }
diff --git a/js/src/jit/CodeGenerator.cpp b/js/src/jit/CodeGenerator.cpp
index 0e35b6ff5a0e..d0bf0290337c 100644
--- a/js/src/jit/CodeGenerator.cpp
+++ b/js/src/jit/CodeGenerator.cpp
@@ -16313,6 +16313,9 @@ void CodeGenerator::visitRandom(LRandom* ins) {
   masm.movePtr(ImmPtr(rng), rngReg);
 
   masm.randomDouble(rngReg, output, temp1, temp2);
+  if (js::SupportDifferentialTesting()) {
+    masm.zeroDouble(output);
+  }
 }
 
 void CodeGenerator::visitSignExtendInt32(LSignExtendInt32* ins) {
diff --git a/js/src/jsdate.cpp b/js/src/jsdate.cpp
index f3be788bfcc9..024829275bd5 100644
--- a/js/src/jsdate.cpp
+++ b/js/src/jsdate.cpp
@@ -41,6 +41,7 @@
 #include "js/Object.h"  // JS::GetBuiltinClass
 #include "js/PropertySpec.h"
 #include "js/Wrapper.h"
+#include "util/DifferentialTesting.h"
 #include "util/StringBuffer.h"
 #include "util/Text.h"
 #include "vm/DateObject.h"
@@ -1517,6 +1518,10 @@ static bool date_parse(JSContext* cx, unsigned argc, Value* vp) {
 }
 
 static ClippedTime NowAsMillis(JSContext* cx) {
+  if (js::SupportDifferentialTesting()) {
+    return TimeClip(0);
+  }
+
   double now = PRMJ_Now();
   bool clampAndJitter = cx->realm()->behaviors().clampAndJitterTime();
   if (clampAndJitter && sReduceMicrosecondTimePrecisionCallback) {
diff --git a/js/src/jsmath.cpp b/js/src/jsmath.cpp
index fdcc1a9bb4b9..c1e59402ce5d 100644
--- a/js/src/jsmath.cpp
+++ b/js/src/jsmath.cpp
@@ -25,6 +25,7 @@
 #include "jit/InlinableNatives.h"
 #include "js/Class.h"
 #include "js/PropertySpec.h"
+#include "util/DifferentialTesting.h"
 #include "vm/JSContext.h"
 #include "vm/Realm.h"
 #include "vm/Time.h"
@@ -519,7 +520,12 @@ double js::math_random_impl(JSContext* cx) {
 
 static bool math_random(JSContext* cx, unsigned argc, Value* vp) {
   CallArgs args = CallArgsFromVp(argc, vp);
-  args.rval().setDouble(math_random_impl(cx));
+  if (js::SupportDifferentialTesting()) {
+    args.rval().setDouble(0);
+  }
+  else {
+    args.rval().setDouble(math_random_impl(cx));
+  }
   return true;
 }
 
diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
index 9e90314127d7..63d1a9c89110 100644
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -8737,10 +8737,6 @@ static const JSFunctionSpecWithHelp shell_functions[] = {
 "  argument sets the source buffer. Subsequent calls without an argument\n"
 "  then read from this buffer line by line.\n"),
 
-    JS_FN_HELP("print", Print, 0, 0,
-"print([exp ...])",
-"  Evaluate and print expressions to stdout."),
-
     JS_FN_HELP("printErr", PrintErr, 0, 0,
 "printErr([exp ...])",
 "  Evaluate and print expressions to stderr."),
@@ -9194,20 +9190,11 @@ static const JSFunctionSpecWithHelp shell_functions[] = {
 "string 'eval:FILENAME' if the code was invoked by 'eval' or something\n"
 "similar.\n"),
 
-    JS_FN_HELP("enqueueJob", EnqueueJob, 1, 0,
-"enqueueJob(fn)",
-"  Enqueue 'fn' on the shell's job queue."),
-
     JS_FN_HELP("globalOfFirstJobInQueue", GlobalOfFirstJobInQueue, 0, 0,
 "globalOfFirstJobInQueue()",
 "  Returns the global of the first item in the job queue. Throws an exception\n"
 "  if the queue is empty.\n"),
 
-    JS_FN_HELP("drainJobQueue", DrainJobQueue, 0, 0,
-"drainJobQueue()",
-"Take jobs from the shell's job queue in FIFO order and run them until the\n"
-"queue is empty.\n"),
-
     JS_FN_HELP("setPromiseRejectionTrackerCallback", SetPromiseRejectionTrackerCallback, 1, 0,
 "setPromiseRejectionTrackerCallback()",
 "Sets the callback to be invoked whenever a Promise rejection is unhandled\n"
@@ -9306,6 +9293,16 @@ static const JSFunctionSpecWithHelp shell_functions[] = {
 " Returns the approximate processor time used by the process since an arbitrary epoch, in seconds.\n"
 " Only the difference between two calls to `cpuNow()` is meaningful."),
 
+    JS_FS_HELP_END
+};
+// clang-format on
+
+// clang-format off
+static const JSFunctionSpecWithHelp shell_functions_deterministic[] = {
+    JS_FN_HELP("print", Print, 0, 0,
+"print([exp ...])",
+"  Evaluate and print expressions to stdout."),
+
 #ifdef FUZZING_JS_FUZZILLI
     JS_FN_HELP("fuzzilli", Fuzzilli, 0, 0,
 "fuzzilli(operation, arg)",
@@ -9318,6 +9315,15 @@ static const JSFunctionSpecWithHelp shell_functions[] = {
 "  Call wasm-smith to generate a random wasm module from the provided data."),
 #endif
 
+    JS_FN_HELP("enqueueJob", EnqueueJob, 1, 0,
+"enqueueJob(fn)",
+"  Enqueue 'fn' on the shell's job queue."),
+
+    JS_FN_HELP("drainJobQueue", DrainJobQueue, 0, 0,
+"drainJobQueue()",
+"Take jobs from the shell's job queue in FIFO order and run them until the\n"
+"queue is empty.\n"),
+
     JS_FS_HELP_END
 };
 // clang-format on
@@ -10210,10 +10216,15 @@ static JSObject* NewGlobalObject(JSContext* cx, JS::RealmOptions& options,
     if (!JS_DefineDebuggerObject(cx, glob)) {
       return nullptr;
     }
-    if (!JS_DefineFunctionsWithHelp(cx, glob, shell_functions) ||
-        !JS_DefineProfilingFunctions(cx, glob)) {
+    if (!JS_DefineFunctionsWithHelp(cx, glob, shell_functions_deterministic)) {
       return nullptr;
     }
+    if (!js::SupportDifferentialTesting()) {
+      if (!JS_DefineFunctionsWithHelp(cx, glob, shell_functions) ||
+          !JS_DefineProfilingFunctions(cx, glob)) {
+        return nullptr;
+      }
+    }
     if (!js::DefineTestingFunctions(cx, glob, fuzzingSafe,
                                     disableOOMFunctions)) {
       return nullptr;
@@ -10235,32 +10246,34 @@ static JSObject* NewGlobalObject(JSContext* cx, JS::RealmOptions& options,
       return nullptr;
     }
 
-    RootedObject performanceObj(cx, JS_NewObject(cx, nullptr));
-    if (!performanceObj) {
-      return nullptr;
-    }
-    if (!JS_DefineFunctionsWithHelp(cx, performanceObj,
-                                    performance_functions)) {
-      return nullptr;
-    }
-    RootedObject mozMemoryObj(cx, JS_NewObject(cx, nullptr));
-    if (!mozMemoryObj) {
-      return nullptr;
-    }
-    RootedObject gcObj(cx, gc::NewMemoryInfoObject(cx));
-    if (!gcObj) {
-      return nullptr;
-    }
-    if (!JS_DefineProperty(cx, glob, "performance", performanceObj,
-                           JSPROP_ENUMERATE)) {
-      return nullptr;
-    }
-    if (!JS_DefineProperty(cx, performanceObj, "mozMemory", mozMemoryObj,
-                           JSPROP_ENUMERATE)) {
-      return nullptr;
-    }
-    if (!JS_DefineProperty(cx, mozMemoryObj, "gc", gcObj, JSPROP_ENUMERATE)) {
-      return nullptr;
+    if (!js::SupportDifferentialTesting()) {
+      RootedObject performanceObj(cx, JS_NewObject(cx, nullptr));
+      if (!performanceObj) {
+        return nullptr;
+      }
+      if (!JS_DefineFunctionsWithHelp(cx, performanceObj,
+                                      performance_functions)) {
+        return nullptr;
+      }
+      RootedObject mozMemoryObj(cx, JS_NewObject(cx, nullptr));
+      if (!mozMemoryObj) {
+        return nullptr;
+      }
+      RootedObject gcObj(cx, gc::NewMemoryInfoObject(cx));
+      if (!gcObj) {
+        return nullptr;
+      }
+      if (!JS_DefineProperty(cx, glob, "performance", performanceObj,
+                             JSPROP_ENUMERATE)) {
+        return nullptr;
+      }
+      if (!JS_DefineProperty(cx, performanceObj, "mozMemory", mozMemoryObj,
+                             JSPROP_ENUMERATE)) {
+        return nullptr;
+      }
+      if (!JS_DefineProperty(cx, mozMemoryObj, "gc", gcObj, JSPROP_ENUMERATE)) {
+        return nullptr;
+      }
     }
 
     /* Initialize FakeDOMObject. */
diff --git a/js/src/vm/BigIntType.cpp b/js/src/vm/BigIntType.cpp
index f81bd43ff248..5059aa6833e0 100644
--- a/js/src/vm/BigIntType.cpp
+++ b/js/src/vm/BigIntType.cpp
@@ -102,6 +102,7 @@
 #include "js/StableStringChars.h"
 #include "js/Utility.h"
 #include "util/CheckedArithmetic.h"
+#include "util/DifferentialTesting.h"
 #include "vm/JSContext.h"
 #include "vm/StaticStrings.h"
 
@@ -2153,6 +2154,9 @@ BigInt* BigInt::lshByAbsolute(JSContext* cx, HandleBigInt x, HandleBigInt y) {
   if (y->digitLength() > 1 || y->digit(0) > MaxBitLength) {
     JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                               JSMSG_BIGINT_TOO_LARGE);
+    if (js::SupportDifferentialTesting()) {
+      fprintf(stderr, "ReportOutOfMemory called\n");
+    }
     return nullptr;
   }
   Digit shift = y->digit(0);
diff --git a/js/src/vm/JSContext.cpp b/js/src/vm/JSContext.cpp
index f953abf6bdb4..48f7d5ad676d 100644
--- a/js/src/vm/JSContext.cpp
+++ b/js/src/vm/JSContext.cpp
@@ -373,6 +373,10 @@ void js::ReportOversizedAllocation(JSContext* cx, const unsigned errorNumber) {
 }
 
 void js::ReportAllocationOverflow(JSContext* cx) {
+  if (js::SupportDifferentialTesting()) {
+    fprintf(stderr, "ReportAllocationOverflow called\n");
+  }
+
   if (!cx) {
     return;
   }
diff --git a/js/src/vm/StructuredClone.cpp b/js/src/vm/StructuredClone.cpp
index 559fd5dad73e..d3cb5a28df23 100644
--- a/js/src/vm/StructuredClone.cpp
+++ b/js/src/vm/StructuredClone.cpp
@@ -55,6 +55,7 @@
 #include "js/ScalarType.h"          // js::Scalar::Type
 #include "js/SharedArrayBuffer.h"   // JS::IsSharedArrayBufferObject
 #include "js/Wrapper.h"
+#include "util/DifferentialTesting.h"
 #include "vm/BigIntType.h"
 #include "vm/ErrorObject.h"
 #include "vm/JSContext.h"
@@ -1263,6 +1264,13 @@ bool JSStructuredCloneWriter::writeString(uint32_t tag, JSString* str) {
     return false;
   }
 
+#if FUZZING_JS_FUZZILLI
+  if (js::SupportDifferentialTesting()) {
+    // TODO we could always output a twoByteChar string
+    return true;
+  }
+#endif
+
   static_assert(JSString::MAX_LENGTH <= INT32_MAX,
                 "String length must fit in 31 bits");
 
@@ -1334,6 +1342,15 @@ bool JSStructuredCloneWriter::writeTypedArray(HandleObject obj) {
                                  obj->maybeUnwrapAs<TypedArrayObject>());
   JSAutoRealm ar(context(), tarr);
 
+#ifdef FUZZING_JS_FUZZILLI
+  if (js::SupportDifferentialTesting() && !tarr->hasBuffer()) {
+    // fake oom because differential testing will fail
+    fprintf(stderr, "[unhandlable oom]");
+    _exit(-1);
+    return false;
+  }
+#endif
+
   if (!TypedArrayObject::ensureHasBuffer(context(), tarr)) {
     return false;
   }
@@ -1575,9 +1592,11 @@ static bool TryAppendNativeProperties(JSContext* cx, HandleObject obj,
 bool JSStructuredCloneWriter::traverseObject(HandleObject obj, ESClass cls) {
   size_t count;
   bool optimized = false;
-  if (!TryAppendNativeProperties(context(), obj, &objectEntries, &count,
-                                 &optimized)) {
-    return false;
+  if (!js::SupportDifferentialTesting()) {
+    if (!TryAppendNativeProperties(context(), obj, &objectEntries, &count,
+                                   &optimized)) {
+      return false;
+    }
   }
 
   if (!optimized) {
@@ -1981,6 +2000,9 @@ bool JSStructuredCloneWriter::writePrimitive(HandleValue v) {
   if (v.isString()) {
     return writeString(SCTAG_STRING, v.toString());
   } else if (v.isInt32()) {
+    if (js::SupportDifferentialTesting()) {
+      return out.writeDouble(v.toInt32());
+    }
     return out.writePair(SCTAG_INT32, v.toInt32());
   } else if (v.isDouble()) {
     return out.writeDouble(v.toDouble());
@@ -2081,6 +2103,14 @@ bool JSStructuredCloneWriter::startWrite(HandleValue v) {
     case ESClass::Map:
       return traverseMap(obj);
     case ESClass::Error:
+#if FUZZING_JS_FUZZILLI
+      // serializing ESClass::Error requires calls into user code which we
+      // must not allow
+      if (js::SupportDifferentialTesting()) {
+        fprintf(stderr, "Differential testing: cannot clone ESClass::Error\n");
+        return false;
+      }
+#endif
       return traverseError(obj);
     case ESClass::BigInt: {
       RootedValue unboxed(context());
@@ -2402,6 +2432,14 @@ bool JSStructuredCloneWriter::write(HandleValue v) {
         }
 
         if (found) {
+#if FUZZING_JS_FUZZILLI
+          // supress calls into user code
+          if (js::SupportDifferentialTesting()) {
+            fprintf(stderr, "Differential testing: cannot call GetProperty\n");
+            return false;
+          }
+#endif
+
           if (!writePrimitive(key) ||
               !GetProperty(context(), obj, obj, id, &val) || !startWrite(val)) {
             return false;
-- 
2.34.1


From 4f92d5c83232f6421967376ffb31a8dfafe68227 Mon Sep 17 00:00:00 2001
From: Lukas Bernhard <15350042+bernhl@users.noreply.github.com>
Date: Sat, 9 Apr 2022 17:13:21 +0200
Subject: [PATCH 2/5] Add fuzzilli_hash to jsshell


diff --git a/js/src/builtin/TestingFunctions.cpp b/js/src/builtin/TestingFunctions.cpp
index e7885664f317..83773db275dd 100644
--- a/js/src/builtin/TestingFunctions.cpp
+++ b/js/src/builtin/TestingFunctions.cpp
@@ -49,6 +49,8 @@
 #  include "builtin/intl/FormatBuffer.h"
 #  include "builtin/intl/SharedIntlData.h"
 #endif
+#include "builtin/BigInt.h"
+#include "builtin/MapObject.h"
 #include "builtin/Promise.h"
 #include "builtin/TestingUtility.h"  // js::ParseCompileOptions, js::ParseDebugMetadata
 #include "frontend/BytecodeCompilation.h"  // frontend::CompileGlobalScriptToExtensibleStencil, frontend::DelazifyCanonicalScriptedFunction
@@ -101,7 +103,11 @@
 #include "util/DifferentialTesting.h"
 #include "util/StringBuffer.h"
 #include "util/Text.h"
-#include "vm/ErrorContext.h"  // AutoReportFrontendContext
+#include "vm/AsyncFunction.h"
+#include "vm/AsyncIteration.h"
+#include "vm/BooleanObject.h"
+#include "vm/DateObject.h"
+#include "vm/ErrorContext.h"
 #include "vm/ErrorObject.h"
 #include "vm/GlobalObject.h"
 #include "vm/HelperThreads.h"
@@ -109,6 +115,7 @@
 #include "vm/Interpreter.h"
 #include "vm/JSContext.h"
 #include "vm/JSObject.h"
+#include "vm/NumberObject.h"
 #include "vm/PlainObject.h"    // js::PlainObject
 #include "vm/PromiseObject.h"  // js::PromiseObject, js::PromiseSlot_*
 #include "vm/ProxyObject.h"
@@ -116,6 +123,7 @@
 #include "vm/ScopeKind.h"
 #include "vm/Stack.h"
 #include "vm/StencilObject.h"  // StencilObject, StencilXDRBufferObject
+#include "vm/StringObject.h"
 #include "vm/StringType.h"
 #include "wasm/AsmJS.h"
 #include "wasm/WasmBaselineCompile.h"
@@ -9207,3 +9215,54 @@ bool js::DefineTestingFunctions(JSContext* cx, HandleObject obj,
     return true;
   }
 }
+
+#ifdef FUZZING_JS_FUZZILLI
+uint32_t js::FuzzilliHashDouble(double value) {
+  // We shouldn't GC here as this is called directly from IC code.
+  AutoUnsafeCallWithABI unsafe;
+  uint64_t v = mozilla::BitwiseCast<uint64_t>(value);
+  return static_cast<uint32_t>(v) + static_cast<uint32_t>(v >> 32);
+}
+
+uint32_t js::FuzzilliHashBigInt(BigInt* bigInt) {
+  // We shouldn't GC here as this is called directly from IC code.
+  AutoUnsafeCallWithABI unsafe;
+  return bigInt->hash();
+}
+
+void js::FuzzilliHashObject(JSContext* cx, JSObject* obj) {
+  // called from IC and baseline/interpreter
+  uint32_t hash;
+  FuzzilliHashObjectInl(cx, obj, &hash);
+
+  cx->executionHashInputs += 1;
+  cx->executionHash = mozilla::RotateLeft(cx->executionHash + hash, 1);
+}
+
+static void fuzzilliSCErrorReporter(JSContext* cx, uint32_t errorid,
+                                    void* closure, const char* errorMessage) {
+}
+
+void js::FuzzilliHashObjectInl(JSContext* cx, JSObject* obj, uint32_t* out) {
+
+  *out = 0;
+  RootedValue v(cx);
+  v.setObject(*obj);
+
+  JSStructuredCloneCallbacks scc = { .reportError = fuzzilliSCErrorReporter };
+
+  JSAutoStructuredCloneBuffer JSCloner(JS::StructuredCloneScope::DifferentProcess,
+                                       &scc, nullptr);
+  if (JSCloner.write(cx, v)) {
+    JSStructuredCloneData& data = JSCloner.data();
+    data.ForEachDataChunk([&](const char* aData, size_t aSize) {
+      uint32_t h = mozilla::HashBytes(aData, aSize);
+      h = (h << 1) | 1;
+      *out ^= h;
+      *out *= h;
+      return true;
+    });
+  }
+  MOZ_ASSERT(!JS_IsExceptionPending(cx));
+}
+#endif
diff --git a/js/src/builtin/TestingFunctions.h b/js/src/builtin/TestingFunctions.h
index 7243e3d48e32..b823fabeb3b8 100644
--- a/js/src/builtin/TestingFunctions.h
+++ b/js/src/builtin/TestingFunctions.h
@@ -30,6 +30,15 @@ namespace js {
 extern JSScript* TestingFunctionArgumentToScript(JSContext* cx, HandleValue v,
                                                  JSFunction** funp = nullptr);
 
+#ifdef FUZZING_JS_FUZZILLI
+uint32_t FuzzilliHashDouble(double value);
+
+uint32_t FuzzilliHashBigInt(BigInt* bigInt);
+
+void FuzzilliHashObjectInl(JSContext* cx, JSObject* obj, uint32_t* out);
+void FuzzilliHashObject(JSContext* cx, JSObject* obj);
+#endif
+
 } /* namespace js */
 
 #endif /* builtin_TestingFunctions_h */
diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
index 63d1a9c89110..bd84d290ddb3 100644
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -14,6 +14,7 @@
 #include "mozilla/IntegerPrintfMacros.h"
 #include "mozilla/mozalloc.h"
 #include "mozilla/PodOperations.h"
+#include "mozilla/RandomNum.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/ScopeExit.h"
 #include "mozilla/Sprintf.h"
@@ -1661,6 +1662,10 @@ static void ReportCantOpenErrorUnknownEncoding(JSContext* cx,
       return false;
     }
   }
+#ifdef FUZZING_JS_FUZZILLI
+  fprintf(stderr, "executionHash is 0x%x with %d inputs\n",
+          cx->executionHash, cx->executionHashInputs);
+#endif
   return true;
 }
 
@@ -3495,6 +3500,51 @@ static bool DummyPreserveWrapperCallback(JSContext* cx, HandleObject obj) {
 static bool DummyHasReleasedWrapperCallback(HandleObject obj) { return true; }
 
 #ifdef FUZZING_JS_FUZZILLI
+static bool fuzzilli_hash(JSContext* cx, unsigned argc, Value* vp) {
+  CallArgs args = CallArgsFromVp(argc, vp);
+  args.rval().setUndefined();
+
+  if (argc != 1) {
+    return true;
+  }
+  uint32_t hash;
+  JS::Handle<JS::Value> v = args.get(0);
+  if (v.isInt32()) {
+    int32_t i = v.toInt32();
+    hash = FuzzilliHashDouble((double)i);
+  }
+  else if (v.isDouble()) {
+    double d = v.toDouble();
+    d = JS::CanonicalizeNaN(d);
+    hash = FuzzilliHashDouble(d);
+  }
+  else if (v.isNull()) {
+    hash = FuzzilliHashDouble(1.0);
+  }
+  else if (v.isUndefined()) {
+    hash = FuzzilliHashDouble(2.0);
+  }
+  else if (v.isBoolean()) {
+    hash = FuzzilliHashDouble(3.0 + v.toBoolean());
+  }
+  else if (v.isBigInt()) {
+    JS::BigInt* bigInt = v.toBigInt();
+    hash = FuzzilliHashBigInt(bigInt);
+  }
+  else if (v.isObject()) {
+    JSObject& obj = v.toObject();
+    FuzzilliHashObject(cx, &obj);
+    return true;
+  }
+  else {
+    hash = 0;
+  }
+
+  cx->executionHashInputs += 1;
+  cx->executionHash = mozilla::RotateLeft(cx->executionHash + hash, 1);
+  return true;
+}
+
 // We have to assume that the fuzzer will be able to call this function e.g. by
 // enumerating the properties of the global object and eval'ing them. As such
 // this function is implemented in a way that requires passing some magic value
@@ -3557,6 +3607,13 @@ static bool Fuzzilli(JSContext* cx, unsigned argc, Value* vp) {
     fprintf(fzliout, "%s\n", bytes.get());
     fflush(fzliout);
   }
+  else if (StringEqualsAscii(operation, "FUZZILLI_RANDOM")) {
+    // This is an entropy source which can be called during fuzzing.
+    // Its currently used to tests whether Fuzzilli detects non-deterministic
+    // behavior.
+    args.rval().setInt32(static_cast<uint32_t>(mozilla::RandomUint64OrDie()));
+    return true;
+  }
 
   args.rval().setUndefined();
   return true;
@@ -9328,6 +9385,15 @@ static const JSFunctionSpecWithHelp shell_functions_deterministic[] = {
 };
 // clang-format on
 
+// clang-format off
+#ifdef FUZZING_JS_FUZZILLI
+static const JSFunctionSpec shell_function_fuzzilli_hash[] = {
+    JS_FN("fuzzilli_hash", fuzzilli_hash, 1, 0),
+    JS_FS_END
+};
+#endif
+// clang-format on
+
 // clang-format off
 static const JSFunctionSpecWithHelp fuzzing_unsafe_functions[] = {
     JS_FN_HELP("getSelfHostedValue", GetSelfHostedValue, 1, 0,
@@ -10219,6 +10285,11 @@ static JSObject* NewGlobalObject(JSContext* cx, JS::RealmOptions& options,
     if (!JS_DefineFunctionsWithHelp(cx, glob, shell_functions_deterministic)) {
       return nullptr;
     }
+#ifdef FUZZING_JS_FUZZILLI
+    if (!JS_DefineFunctions(cx, glob, shell_function_fuzzilli_hash)) {
+      return nullptr;
+    }
+#endif
     if (!js::SupportDifferentialTesting()) {
       if (!JS_DefineFunctionsWithHelp(cx, glob, shell_functions) ||
           !JS_DefineProfilingFunctions(cx, glob)) {
diff --git a/js/src/vm/JSContext.cpp b/js/src/vm/JSContext.cpp
index 48f7d5ad676d..8143fbb4f166 100644
--- a/js/src/vm/JSContext.cpp
+++ b/js/src/vm/JSContext.cpp
@@ -1003,6 +1003,10 @@ JSContext::JSContext(JSRuntime* runtime, const JS::ContextOptions& options)
 #endif
       dtoaState(this, nullptr),
       suppressGC(this, 0),
+#ifdef FUZZING_JS_FUZZILLI
+      executionHash(1),
+      executionHashInputs(0),
+#endif
 #ifdef DEBUG
       noNurseryAllocationCheck(this, 0),
       disableStrictProxyCheckingCount(this, 0),
diff --git a/js/src/vm/JSContext.h b/js/src/vm/JSContext.h
index 9e27180283d6..891d27a7f10f 100644
--- a/js/src/vm/JSContext.h
+++ b/js/src/vm/JSContext.h
@@ -522,6 +522,11 @@ struct JS_PUBLIC_API JSContext : public JS::RootingContext,
    */
   js::ContextData<int32_t> suppressGC;
 
+#ifdef FUZZING_JS_FUZZILLI
+  uint32_t executionHash;
+  uint32_t executionHashInputs;
+#endif
+
 #ifdef DEBUG
   js::ContextData<size_t> noNurseryAllocationCheck;
 
-- 
2.34.1


From b146a1e468615883e53fd2d97d7449845cc2002d Mon Sep 17 00:00:00 2001
From: Lukas Bernhard <15350042+bernhl@users.noreply.github.com>
Date: Sat, 9 Apr 2022 17:50:50 +0200
Subject: [PATCH 3/5] Add fuzzilli_hash as inlinable native


diff --git a/js/src/jit/ABIFunctionList-inl.h b/js/src/jit/ABIFunctionList-inl.h
index 19613d61d112..cbdd7549f01e 100644
--- a/js/src/jit/ABIFunctionList-inl.h
+++ b/js/src/jit/ABIFunctionList-inl.h
@@ -19,6 +19,7 @@
 #include "builtin/Object.h"     // js::ObjectClassToString
 #include "builtin/RegExp.h"     // js::RegExpPrototypeOptimizableRaw,
                                 // js::RegExpInstanceOptimizableRaw
+#include "builtin/TestingFunctions.h" // js::FuzzilliHash*
 
 #include "irregexp/RegExpAPI.h"
 // js::irregexp::CaseInsensitiveCompareNonUnicode,
@@ -80,6 +81,13 @@ namespace jit {
 #  define ABIFUNCTION_WASM_CODEGEN_DEBUG_LIST(_)
 #endif
 
+#ifdef FUZZING_JS_FUZZILLI
+#  define ABIFUNCTION_FUZZILLI_LIST(_) \
+    _(js::FuzzilliHashBigInt)
+#else
+#  define ABIFUNCTION_FUZZILLI_LIST(_)
+#endif
+
 #define ABIFUNCTION_LIST(_)                                           \
   ABIFUNCTION_JS_GC_PROBES_LIST(_)                                    \
   ABIFUNCTION_JS_CODEGEN_ARM_LIST(_)                                  \
@@ -157,6 +165,7 @@ namespace jit {
   _(js::jit::StringFromCharCodeNoGC)                                  \
   _(js::jit::TypeOfNameObject)                                        \
   _(js::jit::WrapObjectPure)                                          \
+  ABIFUNCTION_FUZZILLI_LIST(_)                                        \
   _(js::MapIteratorObject::next)                                      \
   _(js::NativeObject::addDenseElementPure)                            \
   _(js::NativeObject::growSlotsPure)                                  \
diff --git a/js/src/jit/CacheIR.cpp b/js/src/jit/CacheIR.cpp
index 0d80154061e7..32a61edb6271 100644
--- a/js/src/jit/CacheIR.cpp
+++ b/js/src/jit/CacheIR.cpp
@@ -10019,6 +10019,12 @@ AttachDecision InlinableNativeIRGenerator::tryAttachStub() {
     case InlinableNative::TestAssertRecoveredOnBailout:
       return tryAttachAssertRecoveredOnBailout();
 
+#ifdef FUZZING_JS_FUZZILLI
+    // Fuzzilli function
+    case InlinableNative::FuzzilliHash:
+      return tryAttachFuzzilliHash(callee);
+#endif
+
     case InlinableNative::Limit:
       break;
   }
@@ -10356,6 +10362,30 @@ AttachDecision CallIRGenerator::tryAttachStub() {
   return tryAttachCallNative(calleeFunc);
 }
 
+#ifdef FUZZING_JS_FUZZILLI
+AttachDecision CallIRGenerator::tryAttachFuzzilliHash(HandleFunction callee) {
+  if (argc_ != 1) {
+    return AttachDecision::NoAction;
+  }
+
+  // Initialize the input operand.
+  Int32OperandId argcId(writer.setInputOperandId(0));
+
+  // Guard callee is the 'fuzzilli_hash' native function.
+  emitNativeCalleeGuard(callee);
+
+  ValOperandId argValId =
+      writer.loadArgumentFixedSlot(ArgumentKind::Arg0, argc_);
+
+  writer.fuzzilliHash(argValId);
+  writer.loadUndefinedResult();
+  writer.returnFromIC();
+
+  trackAttached("FuzzilliHash");
+  return AttachDecision::Attach;
+}
+#endif
+
 void CallIRGenerator::trackAttached(const char* name) {
   stubName_ = JS_smprintf("%s", name ? name : "NotAttached");
 #ifdef JS_CACHEIR_SPEW
diff --git a/js/src/jit/CacheIRCompiler.cpp b/js/src/jit/CacheIRCompiler.cpp
index ca225d3b0268..2d3b50780407 100644
--- a/js/src/jit/CacheIRCompiler.cpp
+++ b/js/src/jit/CacheIRCompiler.cpp
@@ -8821,6 +8821,175 @@ bool CacheIRCompiler::emitAssertRecoveredOnBailoutResult(ValOperandId valId,
   return true;
 }
 
+#ifdef FUZZING_JS_FUZZILLI
+bool CacheIRCompiler::emitFuzzilliHash(ValOperandId valId) {
+  JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
+
+  ValueOperand input = allocator.useValueRegister(masm, valId);
+  AutoScratchRegister scratch(allocator, masm);
+  AutoScratchRegister scratchJSContext(allocator, masm);
+  AutoScratchFloatRegister floatReg(this);
+#ifdef JS_PUNBOX64
+    AutoScratchRegister64 scratch64(allocator, masm);
+#else
+    AutoScratchRegister scratch2(allocator, masm);
+#endif
+
+  Label addFloat, updateHash, done;
+
+  {
+    ScratchTagScope tag(masm, input);
+    masm.splitTagForTest(input, tag);
+
+    Label notInt32;
+    masm.branchTestInt32(Assembler::NotEqual, tag, &notInt32);
+    {
+      ScratchTagScopeRelease _(&tag);
+
+      masm.unboxInt32(input, scratch);
+      masm.convertInt32ToDouble(scratch, floatReg);
+      masm.jump(&addFloat);
+    }
+    masm.bind(&notInt32);
+
+    Label notDouble;
+    masm.branchTestDouble(Assembler::NotEqual, tag, &notDouble);
+    {
+      ScratchTagScopeRelease _(&tag);
+
+      masm.unboxDouble(input, floatReg);
+      masm.canonicalizeDouble(floatReg);
+      masm.jump(&addFloat);
+    }
+    masm.bind(&notDouble);
+
+    Label notNull;
+    masm.branchTestNull(Assembler::NotEqual, tag, &notNull);
+    {
+      ScratchTagScopeRelease _(&tag);
+
+      masm.move32(Imm32(1), scratch);
+      masm.convertInt32ToDouble(scratch, floatReg);
+      masm.jump(&addFloat);
+    }
+    masm.bind(&notNull);
+
+    Label notUndefined;
+    masm.branchTestUndefined(Assembler::NotEqual, tag, &notUndefined);
+    {
+      ScratchTagScopeRelease _(&tag);
+
+      masm.move32(Imm32(2), scratch);
+      masm.convertInt32ToDouble(scratch, floatReg);
+      masm.jump(&addFloat);
+    }
+    masm.bind(&notUndefined);
+
+    Label notBoolean;
+    masm.branchTestBoolean(Assembler::NotEqual, tag, &notBoolean);
+    {
+      ScratchTagScopeRelease _(&tag);
+
+      masm.unboxBoolean(input, scratch);
+      masm.add32(Imm32(3), scratch);
+      masm.convertInt32ToDouble(scratch, floatReg);
+      masm.jump(&addFloat);
+    }
+    masm.bind(&notBoolean);
+
+    Label notBigInt;
+    masm.branchTestBigInt(Assembler::NotEqual, tag, &notBigInt);
+    {
+      ScratchTagScopeRelease _(&tag);
+
+      masm.unboxBigInt(input, scratch);
+
+      LiveRegisterSet volatileRegs(GeneralRegisterSet::Volatile(),
+                                   liveVolatileFloatRegs());
+      masm.PushRegsInMask(volatileRegs);
+      // TODO: remove floatReg, scratch, scratchJS?
+
+      using Fn = uint32_t (*)(BigInt* bigInt);
+      masm.setupUnalignedABICall(scratchJSContext);
+      masm.loadJSContext(scratchJSContext);
+      masm.passABIArg(scratch);
+      masm.callWithABI<Fn, js::FuzzilliHashBigInt>();
+      masm.storeCallInt32Result(scratch);
+
+      LiveRegisterSet ignore;
+      ignore.add(scratch);
+      ignore.add(scratchJSContext);
+      masm.PopRegsInMaskIgnore(volatileRegs, ignore);
+      masm.jump(&updateHash);
+    }
+    masm.bind(&notBigInt);
+
+    Label notObject;
+    masm.branchTestObject(Assembler::NotEqual, tag, &notObject);
+    {
+      ScratchTagScopeRelease _(&tag);
+
+      AutoCallVM callvm(masm, this, allocator);
+      Register obj = allocator.allocateRegister(masm);
+      masm.unboxObject(input, obj);
+
+      callvm.prepare();
+      masm.Push(obj);
+
+      using Fn = void (*)(JSContext * cx, JSObject* o);
+      callvm.callNoResult<Fn, js::FuzzilliHashObject>();
+      allocator.releaseRegister(obj);
+
+      masm.jump(&done);
+    }
+    masm.bind(&notObject);
+    {
+      masm.move32(Imm32(0), scratch);
+      masm.jump(&updateHash);
+    }
+  }
+
+  {
+    masm.bind(&addFloat);
+
+    masm.loadJSContext(scratchJSContext);
+    Address addrExecHash(scratchJSContext, offsetof(JSContext, executionHash));
+
+#ifdef JS_PUNBOX64
+    masm.moveDoubleToGPR64(floatReg, scratch64);
+    masm.move32(scratch64.get().reg, scratch);
+    masm.rshift64(Imm32(32), scratch64);
+    masm.add32(scratch64.get().reg, scratch);
+#else
+    Register64 scratch64(scratch, scratch2);
+    masm.moveDoubleToGPR64(floatReg, scratch64);
+    masm.add32(scratch2, scratch);
+#endif
+  }
+
+  {
+    masm.bind(&updateHash);
+
+    masm.loadJSContext(scratchJSContext);
+    Address addrExecHash(scratchJSContext, offsetof(JSContext, executionHash));
+    masm.load32(addrExecHash, scratchJSContext);
+    masm.add32(scratchJSContext, scratch);
+    masm.rotateLeft(Imm32(1), scratch, scratch);
+    masm.loadJSContext(scratchJSContext);
+    masm.store32(scratch, addrExecHash);
+
+    // stats
+    Address addrExecHashInputs(scratchJSContext, offsetof(JSContext, executionHashInputs));
+    masm.load32(addrExecHashInputs, scratch);
+    masm.add32(Imm32(1), scratch);
+    masm.store32(scratch, addrExecHashInputs);
+  }
+
+  masm.bind(&done);
+  return true;
+}
+#endif
+
 template <typename Fn, Fn fn>
 void CacheIRCompiler::callVM(MacroAssembler& masm) {
   VMFunctionId id = VMFunctionToId<Fn, fn>::id;
diff --git a/js/src/jit/CacheIRGenerator.h b/js/src/jit/CacheIRGenerator.h
index d0256f0cde69..22ba7c633b69 100644
--- a/js/src/jit/CacheIRGenerator.h
+++ b/js/src/jit/CacheIRGenerator.h
@@ -497,6 +497,10 @@ class MOZ_RAII CallIRGenerator : public IRGenerator {
   AttachDecision tryAttachCallNative(HandleFunction calleeFunc);
   AttachDecision tryAttachCallHook(HandleObject calleeObj);
 
+#ifdef FUZZING_JS_FUZZILLI
+  AttachDecision tryAttachFuzzilliHash(HandleFunction calleeObj);
+#endif
+
   void trackAttached(const char* name);
 
  public:
diff --git a/js/src/jit/CacheIROps.yaml b/js/src/jit/CacheIROps.yaml
index ee0d2df09a3e..241e79513314 100644
--- a/js/src/jit/CacheIROps.yaml
+++ b/js/src/jit/CacheIROps.yaml
@@ -2921,3 +2921,12 @@
   args:
     val: ValId
     mustBeRecovered: BoolImm
+
+#ifdef FUZZING_JS_FUZZILLI
+- name: FuzzilliHash
+  shared: true
+  transpile: false
+  cost_estimate: 4
+  args:
+    val: ValId
+#endif
diff --git a/js/src/jit/InlinableNatives.cpp b/js/src/jit/InlinableNatives.cpp
index 75ad522a567e..af8936be3c4e 100644
--- a/js/src/jit/InlinableNatives.cpp
+++ b/js/src/jit/InlinableNatives.cpp
@@ -282,6 +282,9 @@ bool js::jit::CanInlineNativeCrossRealm(InlinableNative native) {
     case InlinableNative::ObjectIsPrototypeOf:
     case InlinableNative::ObjectToString:
     case InlinableNative::TypedArrayConstructor:
+#ifdef FUZZING_JS_FUZZILLI
+    case InlinableNative::FuzzilliHash:
+#endif
       // Default to false for most natives.
       return false;
 
diff --git a/js/src/jit/InlinableNatives.h b/js/src/jit/InlinableNatives.h
index 2d120a38e7a2..bd83cd5ba3f9 100644
--- a/js/src/jit/InlinableNatives.h
+++ b/js/src/jit/InlinableNatives.h
@@ -9,6 +9,13 @@
 
 #include <stdint.h>  // For uint16_t
 
+#ifdef FUZZING_JS_FUZZILLI
+#  define INLINABLE_NATIVE_FUZZILLI_LIST(_) \
+    _(FuzzilliHash)
+#else
+#  define INLINABLE_NATIVE_FUZZILLI_LIST(_)
+#endif
+
 #define INLINABLE_NATIVE_LIST(_)                   \
   _(Array)                                         \
   _(ArrayIsArray)                                  \
@@ -197,7 +204,10 @@
   _(IntrinsicTypedArrayLength)                     \
   _(IntrinsicPossiblyWrappedTypedArrayLength)      \
   _(IntrinsicTypedArrayByteOffset)                 \
-  _(IntrinsicTypedArrayElementSize)
+  _(IntrinsicTypedArrayElementSize)                \
+                                                   \
+  INLINABLE_NATIVE_FUZZILLI_LIST(_)
+
 
 struct JSClass;
 class JSJitInfo;
diff --git a/js/src/jit/VMFunctionList-inl.h b/js/src/jit/VMFunctionList-inl.h
index 2b040d4ccedd..2642a0f227c8 100644
--- a/js/src/jit/VMFunctionList-inl.h
+++ b/js/src/jit/VMFunctionList-inl.h
@@ -13,6 +13,7 @@
 #include "builtin/Promise.h"       // js::AsyncFunctionAwait
 #include "builtin/RegExp.h"
 #include "builtin/String.h"
+#include "builtin/TestingFunctions.h"
 #include "jit/BaselineIC.h"
 #include "jit/Ion.h"
 #include "jit/IonIC.h"
@@ -32,6 +33,15 @@
 namespace js {
 namespace jit {
 
+#ifdef FUZZING_JS_FUZZILLI
+#  define VMFUNCTION_FUZZILLI_LIST(_)                   \
+    _(FuzzilliHashObject, js::FuzzilliHashObject)       \
+    _(FuzzilliHashObjectInl, js::FuzzilliHashObjectInl)
+#else
+#  define VMFUNCTION_FUZZILLI_LIST(_)
+#endif
+
+
 // List of all VM functions to be used with callVM. Each entry stores the name
 // (must be unique, used for the VMFunctionId enum and profiling) and the C++
 // function to be called. This list must be sorted on the name field.
@@ -139,6 +149,7 @@ namespace jit {
   _(FinishBoundFunctionInit, JSFunction::finishBoundFunctionInit)              \
   _(FreshenLexicalEnv, js::jit::FreshenLexicalEnv)                             \
   _(FunWithProtoOperation, js::FunWithProtoOperation)                          \
+  VMFUNCTION_FUZZILLI_LIST(_)                                                  \
   _(GeneratorThrowOrReturn, js::jit::GeneratorThrowOrReturn)                   \
   _(GetAndClearException, js::GetAndClearException)                            \
   _(GetFirstDollarIndexRaw, js::GetFirstDollarIndexRaw)                        \
diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
index bd84d290ddb3..f567e68dfbfb 100644
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -9388,7 +9388,7 @@ static const JSFunctionSpecWithHelp shell_functions_deterministic[] = {
 // clang-format off
 #ifdef FUZZING_JS_FUZZILLI
 static const JSFunctionSpec shell_function_fuzzilli_hash[] = {
-    JS_FN("fuzzilli_hash", fuzzilli_hash, 1, 0),
+    JS_INLINABLE_FN("fuzzilli_hash", fuzzilli_hash, 1, 0, FuzzilliHash),
     JS_FS_END
 };
 #endif
-- 
2.34.1


From 7f1b7834d0ee9ed2eee529ff6a2ffe40b1faf7c7 Mon Sep 17 00:00:00 2001
From: Lukas Bernhard <15350042+bernhl@users.noreply.github.com>
Date: Sat, 9 Apr 2022 18:10:11 +0200
Subject: [PATCH 4/5] Warp fuzzilli_hash


diff --git a/js/src/jit/CacheIR.cpp b/js/src/jit/CacheIR.cpp
index 32a61edb6271..a49c5e931d18 100644
--- a/js/src/jit/CacheIR.cpp
+++ b/js/src/jit/CacheIR.cpp
@@ -9613,6 +9613,30 @@ AttachDecision CallIRGenerator::tryAttachInlinableNative(HandleFunction callee,
   return nativeGen.tryAttachStub();
 }
 
+#ifdef FUZZING_JS_FUZZILLI
+AttachDecision InlinableNativeIRGenerator::tryAttachFuzzilliHash() {
+  if (argc_ != 1) {
+    return AttachDecision::NoAction;
+  }
+
+  // Initialize the input operand.
+  initializeInputOperand();
+
+  // Guard callee is the 'fuzzilli_hash' native function.
+  emitNativeCalleeGuard();
+
+  ValOperandId argValId =
+      writer.loadArgumentFixedSlot(ArgumentKind::Arg0, argc_);
+
+  writer.fuzzilliHashResult(argValId);
+  //writer.loadUndefinedResult();
+  writer.returnFromIC();
+
+  trackAttached("FuzzilliHash");
+  return AttachDecision::Attach;
+}
+#endif
+
 AttachDecision InlinableNativeIRGenerator::tryAttachStub() {
   if (!callee_->hasJitInfo() ||
       callee_->jitInfo()->type() != JSJitInfo::InlinableNative) {
@@ -10022,7 +10046,7 @@ AttachDecision InlinableNativeIRGenerator::tryAttachStub() {
 #ifdef FUZZING_JS_FUZZILLI
     // Fuzzilli function
     case InlinableNative::FuzzilliHash:
-      return tryAttachFuzzilliHash(callee);
+      return tryAttachFuzzilliHash();
 #endif
 
     case InlinableNative::Limit:
@@ -10362,30 +10386,6 @@ AttachDecision CallIRGenerator::tryAttachStub() {
   return tryAttachCallNative(calleeFunc);
 }
 
-#ifdef FUZZING_JS_FUZZILLI
-AttachDecision CallIRGenerator::tryAttachFuzzilliHash(HandleFunction callee) {
-  if (argc_ != 1) {
-    return AttachDecision::NoAction;
-  }
-
-  // Initialize the input operand.
-  Int32OperandId argcId(writer.setInputOperandId(0));
-
-  // Guard callee is the 'fuzzilli_hash' native function.
-  emitNativeCalleeGuard(callee);
-
-  ValOperandId argValId =
-      writer.loadArgumentFixedSlot(ArgumentKind::Arg0, argc_);
-
-  writer.fuzzilliHash(argValId);
-  writer.loadUndefinedResult();
-  writer.returnFromIC();
-
-  trackAttached("FuzzilliHash");
-  return AttachDecision::Attach;
-}
-#endif
-
 void CallIRGenerator::trackAttached(const char* name) {
   stubName_ = JS_smprintf("%s", name ? name : "NotAttached");
 #ifdef JS_CACHEIR_SPEW
diff --git a/js/src/jit/CacheIRCompiler.cpp b/js/src/jit/CacheIRCompiler.cpp
index 2d3b50780407..c575b2374247 100644
--- a/js/src/jit/CacheIRCompiler.cpp
+++ b/js/src/jit/CacheIRCompiler.cpp
@@ -8822,7 +8822,7 @@ bool CacheIRCompiler::emitAssertRecoveredOnBailoutResult(ValOperandId valId,
 }
 
 #ifdef FUZZING_JS_FUZZILLI
-bool CacheIRCompiler::emitFuzzilliHash(ValOperandId valId) {
+bool CacheIRCompiler::emitFuzzilliHashResult(ValOperandId valId) {
   JitSpew(JitSpew_Codegen, "%s", __FUNCTION__);
 
   ValueOperand input = allocator.useValueRegister(masm, valId);
@@ -8986,6 +8986,9 @@ bool CacheIRCompiler::emitFuzzilliHash(ValOperandId valId) {
   }
 
   masm.bind(&done);
+
+  AutoOutputRegister output(*this);
+  masm.moveValue(UndefinedValue(), output.valueReg());
   return true;
 }
 #endif
diff --git a/js/src/jit/CacheIRGenerator.h b/js/src/jit/CacheIRGenerator.h
index 22ba7c633b69..64aa0f1c66f9 100644
--- a/js/src/jit/CacheIRGenerator.h
+++ b/js/src/jit/CacheIRGenerator.h
@@ -497,10 +497,6 @@ class MOZ_RAII CallIRGenerator : public IRGenerator {
   AttachDecision tryAttachCallNative(HandleFunction calleeFunc);
   AttachDecision tryAttachCallHook(HandleObject calleeObj);
 
-#ifdef FUZZING_JS_FUZZILLI
-  AttachDecision tryAttachFuzzilliHash(HandleFunction calleeObj);
-#endif
-
   void trackAttached(const char* name);
 
  public:
@@ -663,6 +659,9 @@ class MOZ_RAII InlinableNativeIRGenerator {
   AttachDecision tryAttachSetHas();
   AttachDecision tryAttachMapHas();
   AttachDecision tryAttachMapGet();
+#ifdef FUZZING_JS_FUZZILLI
+  AttachDecision tryAttachFuzzilliHash();
+#endif
 
   void trackAttached(const char* name) {
     return generator_.trackAttached(name);
diff --git a/js/src/jit/CacheIROps.yaml b/js/src/jit/CacheIROps.yaml
index 241e79513314..1bf293c5a6f9 100644
--- a/js/src/jit/CacheIROps.yaml
+++ b/js/src/jit/CacheIROps.yaml
@@ -2923,9 +2923,9 @@
     mustBeRecovered: BoolImm
 
 #ifdef FUZZING_JS_FUZZILLI
-- name: FuzzilliHash
+- name: FuzzilliHashResult
   shared: true
-  transpile: false
+  transpile: true
   cost_estimate: 4
   args:
     val: ValId
diff --git a/js/src/jit/CodeGenerator.cpp b/js/src/jit/CodeGenerator.cpp
index d0bf0290337c..c87d8bef43b4 100644
--- a/js/src/jit/CodeGenerator.cpp
+++ b/js/src/jit/CodeGenerator.cpp
@@ -17469,6 +17469,218 @@ void CodeGenerator::visitWasmAnyRefFromJSObject(LWasmAnyRefFromJSObject* lir) {
   }
 }
 
+#ifdef FUZZING_JS_FUZZILLI
+void CodeGenerator::emitFuzzilliHashDouble(
+    FloatRegister floatDouble, Register scratch, Register output) {
+#ifdef JS_PUNBOX64
+  Register64 reg64_1(scratch);
+  Register64 reg64_2(output);
+  masm.moveDoubleToGPR64(floatDouble, reg64_1);
+  masm.move64(reg64_1, reg64_2);
+  masm.rshift64(Imm32(32), reg64_2);
+  masm.add32(scratch, output);
+#else
+  Register64 reg64(scratch, output);
+  masm.moveDoubleToGPR64(floatDouble, reg64);
+  masm.add32(scratch, output);
+#endif
+}
+
+void CodeGenerator::emitFuzzilliHashObject(
+    LInstruction* lir, Register obj, Register output) {
+
+  using Fn = void (*)(JSContext * cx, JSObject* obj, uint32_t* out);
+  OutOfLineCode* ool = oolCallVM<Fn, FuzzilliHashObjectInl>(
+      lir, ArgList(obj), StoreRegisterTo(output));
+
+  masm.jump(ool->entry());
+  masm.bind(ool->rejoin());
+}
+
+void CodeGenerator::emitFuzzilliHashBigInt(Register bigInt, Register output) {
+  LiveRegisterSet volatileRegs(GeneralRegisterSet::All(),
+                               FloatRegisterSet::All());
+  volatileRegs.takeUnchecked(output);
+  masm.PushRegsInMask(volatileRegs);
+
+  using Fn = uint32_t (*)(BigInt* bigInt);
+  masm.setupUnalignedABICall(output);
+  masm.passABIArg(bigInt);
+  masm.callWithABI<Fn, js::FuzzilliHashBigInt>();
+  masm.storeCallInt32Result(output);
+
+  masm.PopRegsInMask(volatileRegs);
+}
+
+void CodeGenerator::visitFuzzilliHashV(LFuzzilliHashV* ins) {
+  MOZ_ASSERT(ins->mir()->getOperand(0)->type() == MIRType::Value);
+
+  ValueOperand value = ToValue(ins, 0);
+
+  Label isDouble, isObject, isBigInt, done;
+
+  FloatRegister scratchFloat = ToFloatRegister(ins->getTemp(1));
+  Register scratch = ToRegister(ins->getTemp(0));
+  Register output = ToRegister(ins->output());
+  MOZ_ASSERT(scratch != output);
+
+#ifdef JS_PUNBOX64
+  Register tagReg = ToRegister(ins->getTemp(0));
+  masm.splitTag(value, tagReg);
+#else
+  Register tagReg = value.typeReg();
+#endif
+
+  Label noBigInt;
+  masm.branchTestBigInt(Assembler::NotEqual, tagReg, &noBigInt);
+  masm.unboxBigInt(value, scratch);
+  masm.jump(&isBigInt);
+  masm.bind(&noBigInt);
+
+  Label noObject;
+  masm.branchTestObject(Assembler::NotEqual, tagReg, &noObject);
+  masm.unboxObject(value, scratch);
+  masm.jump(&isObject);
+  masm.bind(&noObject);
+
+  Label noInt32;
+  masm.branchTestInt32(Assembler::NotEqual, tagReg, &noInt32);
+  masm.unboxInt32(value, scratch);
+  masm.convertInt32ToDouble(scratch, scratchFloat);
+  masm.jump(&isDouble);
+  masm.bind(&noInt32);
+
+  Label noNull;
+  masm.branchTestNull(Assembler::NotEqual, tagReg, &noNull);
+  masm.move32(Imm32(1), scratch);
+  masm.convertInt32ToDouble(scratch, scratchFloat);
+  masm.jump(&isDouble);
+  masm.bind(&noNull);
+
+  Label noUndefined;
+  masm.branchTestUndefined(Assembler::NotEqual, tagReg, &noUndefined);
+  masm.move32(Imm32(2), scratch);
+  masm.convertInt32ToDouble(scratch, scratchFloat);
+  masm.jump(&isDouble);
+  masm.bind(&noUndefined);
+
+  Label noBoolean;
+  masm.branchTestBoolean(Assembler::NotEqual, tagReg, &noBoolean);
+  masm.unboxBoolean(value, scratch);
+  masm.add32(Imm32(3), scratch);
+  masm.convertInt32ToDouble(scratch, scratchFloat);
+  masm.jump(&isDouble);
+  masm.bind(&noBoolean);
+
+  Label noDouble;
+  masm.branchTestDouble(Assembler::NotEqual, tagReg, &noDouble);
+  masm.unboxDouble(value, scratchFloat);
+  masm.canonicalizeDoubleIfDeterministic(scratchFloat);
+
+  masm.jump(&isDouble);
+  masm.bind(&noDouble);
+  masm.move32(Imm32(0), output);
+  masm.jump(&done);
+
+  masm.bind(&isBigInt);
+  emitFuzzilliHashBigInt(scratch, output);
+  masm.jump(&done);
+
+  masm.bind(&isObject);
+  emitFuzzilliHashObject(ins, scratch, output);
+  masm.jump(&done);
+
+  masm.bind(&isDouble);
+  emitFuzzilliHashDouble(scratchFloat, scratch, output);
+
+  masm.bind(&done);
+}
+
+void CodeGenerator::visitFuzzilliHashT(LFuzzilliHashT* ins) {
+  const LAllocation* value = ins->value();
+  MIRType mirType = ins->mir()->getOperand(0)->type();
+
+  FloatRegister scratchFloat = ToFloatRegister(ins->getTemp(1));
+  Register scratch = ToRegister(ins->getTemp(0));
+  Register output = ToRegister(ins->output());
+  MOZ_ASSERT(scratch != output);
+
+  if (mirType == MIRType::Object) {
+    MOZ_ASSERT(value->isGeneralReg());
+    masm.mov(value->toGeneralReg()->reg(), scratch);
+    emitFuzzilliHashObject(ins, scratch, output);
+  }
+  else if (mirType == MIRType::BigInt) {
+    MOZ_ASSERT(value->isGeneralReg());
+    masm.mov(value->toGeneralReg()->reg(), scratch);
+    emitFuzzilliHashBigInt(scratch, output);
+  }
+  else if (mirType == MIRType::Double) {
+    MOZ_ASSERT(value->isFloatReg());
+    masm.moveDouble(value->toFloatReg()->reg(), scratchFloat);
+    masm.canonicalizeDoubleIfDeterministic(scratchFloat);
+    emitFuzzilliHashDouble(scratchFloat, scratch, output);
+  }
+  else if (mirType == MIRType::Float32) {
+    MOZ_ASSERT(value->isFloatReg());
+    masm.convertFloat32ToDouble(value->toFloatReg()->reg(), scratchFloat);
+    masm.canonicalizeDoubleIfDeterministic(scratchFloat);
+    emitFuzzilliHashDouble(scratchFloat, scratch, output);
+  }
+  else if (mirType == MIRType::Int32) {
+    MOZ_ASSERT(value->isGeneralReg());
+    masm.mov(value->toGeneralReg()->reg(), scratch);
+    masm.convertInt32ToDouble(scratch, scratchFloat);
+    emitFuzzilliHashDouble(scratchFloat, scratch, output);
+  }
+  else if (mirType == MIRType::Null) {
+    MOZ_ASSERT(value->isBogus());
+    masm.move32(Imm32(1), scratch);
+    masm.convertInt32ToDouble(scratch, scratchFloat);
+    emitFuzzilliHashDouble(scratchFloat, scratch, output);
+  }
+  else if (mirType == MIRType::Undefined) {
+    MOZ_ASSERT(value->isBogus());
+    masm.move32(Imm32(2), scratch);
+    masm.convertInt32ToDouble(scratch, scratchFloat);
+    emitFuzzilliHashDouble(scratchFloat, scratch, output);
+  }
+  else if (mirType == MIRType::Boolean) {
+    MOZ_ASSERT(value->isGeneralReg());
+    masm.mov(value->toGeneralReg()->reg(), scratch);
+    masm.add32(Imm32(3), scratch);
+    masm.convertInt32ToDouble(scratch, scratchFloat);
+    emitFuzzilliHashDouble(scratchFloat, scratch, output);
+  }
+  else {
+    MOZ_CRASH("unexpected type");
+  }
+}
+
+void CodeGenerator::visitFuzzilliHashStore(LFuzzilliHashStore* ins) {
+  const LAllocation* value = ins->value();
+  MOZ_ASSERT(ins->mir()->getOperand(0)->type() == MIRType::Int32);
+  MOZ_ASSERT(value->isGeneralReg());
+
+  Register scratchJSContext = ToRegister(ins->getTemp(0));
+  Register scratch = ToRegister(ins->getTemp(1));
+
+  masm.loadJSContext(scratchJSContext);
+
+  // stats
+  Address addrExecHashInputs(scratchJSContext, offsetof(JSContext, executionHashInputs));
+  masm.load32(addrExecHashInputs, scratch);
+  masm.add32(Imm32(1), scratch);
+  masm.store32(scratch, addrExecHashInputs);
+
+  Address addrExecHash(scratchJSContext, offsetof(JSContext, executionHash));
+  masm.load32(addrExecHash, scratch);
+  masm.add32(value->toGeneralReg()->reg(), scratch);
+  masm.rotateLeft(Imm32(1), scratch, scratch);
+  masm.store32(scratch, addrExecHash);
+}
+#endif
+
 static_assert(!std::is_polymorphic_v<CodeGenerator>,
               "CodeGenerator should not have any virtual methods");
 
diff --git a/js/src/jit/CodeGenerator.h b/js/src/jit/CodeGenerator.h
index a5278346f625..00a02b4acbd3 100644
--- a/js/src/jit/CodeGenerator.h
+++ b/js/src/jit/CodeGenerator.h
@@ -369,6 +369,13 @@ class CodeGenerator final : public CodeGeneratorSpecific {
   // Bit mask of JitRealm stubs that are to be read-barriered.
   uint32_t realmStubsToReadBarrier_;
 
+#ifdef FUZZING_JS_FUZZILLI
+  void emitFuzzilliHashDouble(FloatRegister floatDouble, Register scratch,
+                              Register output);
+  void emitFuzzilliHashObject(LInstruction* lir, Register obj, Register output);
+  void emitFuzzilliHashBigInt(Register bigInt, Register output);
+#endif
+
 #define LIR_OP(op) void visit##op(L##op* ins);
   LIR_OPCODE_LIST(LIR_OP)
 #undef LIR_OP
diff --git a/js/src/jit/LIROps.yaml b/js/src/jit/LIROps.yaml
index c2d6d6719758..7057ed19306b 100644
--- a/js/src/jit/LIROps.yaml
+++ b/js/src/jit/LIROps.yaml
@@ -3752,3 +3752,14 @@
 - name: WasmAtomicExchangeI64
   gen_boilerplate: false
 #endif
+
+#ifdef FUZZING_JS_FUZZILLI
+- name: FuzzilliHashT
+  gen_boilerplate: false
+
+- name: FuzzilliHashV
+  gen_boilerplate: false
+
+- name: FuzzilliHashStore
+  gen_boilerplate: false
+#endif
diff --git a/js/src/jit/Lowering.cpp b/js/src/jit/Lowering.cpp
index db603c0b5b19..6139efa1ae28 100644
--- a/js/src/jit/Lowering.cpp
+++ b/js/src/jit/Lowering.cpp
@@ -6756,6 +6756,48 @@ void LIRGenerator::visitWasmStoreObjectDataRefField(
   add(new (alloc()) LKeepAliveObject(useKeepalive(ins->obj())), ins);
 }
 
+#ifdef FUZZING_JS_FUZZILLI
+void LIRGenerator::visitFuzzilliHash(MFuzzilliHash* ins) {
+  MDefinition* value = ins->getOperand(0);
+
+  if (value->type() == MIRType::Undefined ||
+      value->type() == MIRType::Null) {
+    define(new (alloc()) LFuzzilliHashT(LAllocation(),
+                                        temp(), tempDouble()), ins);
+  }
+  else if (value->type() == MIRType::Int32 ||
+           value->type() == MIRType::Double ||
+           value->type() == MIRType::Float32 ||
+           value->type() == MIRType::Boolean ||
+           value->type() == MIRType::BigInt) {
+    define(new (alloc()) LFuzzilliHashT(useRegister(value),
+                                        temp(), tempDouble()), ins);
+  }
+  else if (value->type() == MIRType::Object) {
+    LFuzzilliHashT* lir = new (alloc()) LFuzzilliHashT(useRegister(value),
+                                                       temp(), tempDouble());
+    define(lir, ins);
+    assignSafepoint(lir, ins);
+  }
+  else if (value->type() == MIRType::Value) {
+    LFuzzilliHashV* lir = new (alloc()) LFuzzilliHashV(useBox(value),
+                                                       temp(), tempDouble());
+    define(lir, ins);
+    assignSafepoint(lir, ins);
+  }
+  else {
+    define(new (alloc()) LInteger(0), ins);
+  }
+}
+
+void LIRGenerator::visitFuzzilliHashStore(MFuzzilliHashStore* ins) {
+  MDefinition* value = ins->getOperand(0);
+  MOZ_ASSERT(value->type() == MIRType::Int32);
+  add(new (alloc()) LFuzzilliHashStore(useRegister(value),
+                                       temp(), temp()), ins);
+}
+#endif
+
 static_assert(!std::is_polymorphic_v<LIRGenerator>,
               "LIRGenerator should not have any virtual methods");
 
diff --git a/js/src/jit/MIR.h b/js/src/jit/MIR.h
index 184ad53f60c2..dae30382ff03 100644
--- a/js/src/jit/MIR.h
+++ b/js/src/jit/MIR.h
@@ -358,7 +358,10 @@ class AliasSet {
     // The pendingException slot on the wasm instance object.
     WasmPendingException = 1 << 18,
 
-    Last = WasmPendingException,
+    // The fuzzilliHash slot
+    FuzzilliHash = 1 << 18,
+
+    Last = FuzzilliHash,
 
     Any = Last | (Last - 1),
     NumCategories = 19,
@@ -833,6 +836,9 @@ class MDefinition : public MNode {
   void setDependency(MDefinition* dependency) {
     MOZ_ASSERT(!getAliasSet().isStore());
     loadDependency_ = dependency;
+#ifdef FUZZING_JS_FUZZILLI
+    MOZ_ASSERT(!dependency->isFuzzilliHashStore());
+#endif
   }
   bool isEffectful() const { return getAliasSet().isStore(); }
 
@@ -852,6 +858,11 @@ class MDefinition : public MNode {
       return AliasType::NoAlias;
     }
     MOZ_ASSERT(!isEffectful() && store->isEffectful());
+#ifdef FUZZING_JS_FUZZILLI
+    if (store->isFuzzilliHashStore()) {
+      return AliasType::NoAlias;
+    }
+#endif
     return AliasType::MayAlias;
   }
 
@@ -10818,6 +10829,58 @@ class MWasmStoreObjectDataRefField : public MAryInstruction<4>,
   }
 };
 
+#ifdef FUZZING_JS_FUZZILLI
+class MFuzzilliHash : public MUnaryInstruction, public NoTypePolicy::Data {
+
+  MFuzzilliHash(MDefinition* obj)
+      : MUnaryInstruction(classOpcode, obj) {
+    setResultType(MIRType::Int32);
+    setMovable();
+  }
+
+ public:
+  INSTRUCTION_HEADER(FuzzilliHash);
+  TRIVIAL_NEW_WRAPPERS
+  ALLOW_CLONE(MFuzzilliHash)
+
+#ifdef DEBUG
+  bool isConsistentFloat32Use(MUse* use) const override { return true; }
+#endif
+
+  AliasSet getAliasSet() const override {
+    MDefinition* obj = getOperand(0);
+    if (obj->type() == MIRType::Object ||
+        obj->type() == MIRType::Value) {
+      return AliasSet::Load(AliasSet::ObjectFields | AliasSet::FixedSlot |
+                            AliasSet::DynamicSlot | AliasSet::Element |
+                            AliasSet::UnboxedElement);
+    }
+    return AliasSet::None();
+  }
+};
+
+class MFuzzilliHashStore : public MUnaryInstruction, public NoTypePolicy::Data {
+
+  MFuzzilliHashStore(MDefinition* obj)
+      : MUnaryInstruction(classOpcode, obj) {
+    MOZ_ASSERT(obj->type() == MIRType::Int32);
+
+    setResultType(MIRType::None);
+  }
+
+ public:
+  INSTRUCTION_HEADER(FuzzilliHashStore);
+  TRIVIAL_NEW_WRAPPERS
+  ALLOW_CLONE(MFuzzilliHashStore)
+
+  // this is a store and hence effectful, however no other load can
+  // alias with the store
+  AliasSet getAliasSet() const override {
+    return AliasSet::Store(AliasSet::FuzzilliHash);
+  }
+};
+#endif
+
 #undef INSTRUCTION_HEADER
 
 void MUse::init(MDefinition* producer, MNode* consumer) {
diff --git a/js/src/jit/MIROps.yaml b/js/src/jit/MIROps.yaml
index 97b4841ae8f3..892433242d01 100644
--- a/js/src/jit/MIROps.yaml
+++ b/js/src/jit/MIROps.yaml
@@ -2834,3 +2834,11 @@
 
 - name: WasmStoreObjectDataRefField
   gen_boilerplate: false
+
+#ifdef FUZZING_JS_FUZZILLI
+- name: FuzzilliHash
+  gen_boilerplate: false
+
+- name: FuzzilliHashStore
+  gen_boilerplate: false
+#endif
diff --git a/js/src/jit/WarpCacheIRTranspiler.cpp b/js/src/jit/WarpCacheIRTranspiler.cpp
index 3f8fbe685216..4ea6a629591a 100644
--- a/js/src/jit/WarpCacheIRTranspiler.cpp
+++ b/js/src/jit/WarpCacheIRTranspiler.cpp
@@ -5355,6 +5355,21 @@ bool WarpCacheIRTranspiler::emitCloseIterScriptedResult(ObjOperandId iterId,
   return true;
 }
 
+#ifdef FUZZING_JS_FUZZILLI
+bool WarpCacheIRTranspiler::emitFuzzilliHashResult(ValOperandId valId) {
+  MDefinition* input = getOperand(valId);
+
+  auto* hash = MFuzzilliHash::New(alloc(), input);
+  add(hash);
+
+  auto* store = MFuzzilliHashStore::New(alloc(), hash);
+  addEffectful(store);
+  pushResult(constant(UndefinedValue()));
+
+  return resumeAfter(store);
+}
+#endif
+
 static void MaybeSetImplicitlyUsed(uint32_t numInstructionIdsBefore,
                                    MDefinition* input) {
   // When building MIR from bytecode, for each MDefinition that's an operand to
diff --git a/js/src/jit/shared/LIR-shared.h b/js/src/jit/shared/LIR-shared.h
index c7cf29567242..75dca6bf4ff6 100644
--- a/js/src/jit/shared/LIR-shared.h
+++ b/js/src/jit/shared/LIR-shared.h
@@ -19,6 +19,57 @@ namespace jit {
 
 LIR_OPCODE_CLASS_GENERATED
 
+#ifdef FUZZING_JS_FUZZILLI
+class LFuzzilliHashT : public LInstructionHelper<1, 1, 2> {
+ public:
+  LIR_HEADER(FuzzilliHashT);
+
+  LFuzzilliHashT(const LAllocation& value,
+                 const LDefinition& temp, const LDefinition& tempFloat)
+      : LInstructionHelper(classOpcode) {
+    setOperand(0, value);
+    setTemp(0, temp);
+    setTemp(1, tempFloat);
+  }
+
+  const LAllocation* value() { return getOperand(0); }
+
+  MFuzzilliHash* mir() const { return mir_->toFuzzilliHash(); }
+};
+
+class LFuzzilliHashV : public LInstructionHelper<1, BOX_PIECES, 2> {
+ public:
+  LIR_HEADER(FuzzilliHashV);
+
+  LFuzzilliHashV(const LBoxAllocation& value,
+                 const LDefinition& temp, const LDefinition& tempFloat)
+      : LInstructionHelper(classOpcode) {
+    setBoxOperand(0, value);
+    setTemp(0, temp);
+    setTemp(1, tempFloat);
+  }
+
+  MFuzzilliHash* mir() const { return mir_->toFuzzilliHash(); }
+};
+
+class LFuzzilliHashStore : public LInstructionHelper<0, 1, 2> {
+ public:
+  LIR_HEADER(FuzzilliHashStore);
+
+  LFuzzilliHashStore(const LAllocation& value, const LDefinition& temp1,
+                     const LDefinition& temp2)
+      : LInstructionHelper(classOpcode) {
+    setOperand(0, value);
+    setTemp(0, temp1);
+    setTemp(1, temp2);
+  }
+
+  const LAllocation* value() { return getOperand(0); }
+
+  MFuzzilliHashStore* mir() const { return mir_->toFuzzilliHashStore(); }
+};
+#endif
+
 class LBox : public LInstructionHelper<BOX_PIECES, 1, 0> {
   MIRType type_;
 
-- 
2.34.1


From b4b8fbc639711cf65dfc660f4e0c403ff46b5db7 Mon Sep 17 00:00:00 2001
From: Lukas Bernhard <15350042+bernhl@users.noreply.github.com>
Date: Sat, 9 Apr 2022 18:16:30 +0200
Subject: [PATCH 5/5] Modify fuzzilli REPRL interface


diff --git a/js/src/shell/js.cpp b/js/src/shell/js.cpp
index f567e68dfbfb..46d75e98b42d 100644
--- a/js/src/shell/js.cpp
+++ b/js/src/shell/js.cpp
@@ -11259,6 +11259,10 @@ static int Shell(JSContext* cx, OptionParser* op) {
     result = EXIT_SUCCESS;
     {
       AutoReportException are(cx);
+#ifdef FUZZING_JS_FUZZILLI
+      cx->executionHash = 1;
+      cx->executionHashInputs = 0;
+#endif
       if (!ProcessArgs(cx, op) && !sc->quitting) {
         result = EXITCODE_RUNTIME_ERROR;
       }
@@ -11289,9 +11293,18 @@ static int Shell(JSContext* cx, OptionParser* op) {
       fflush(stdout);
       fflush(stderr);
       // Send return code to parent and reset edge counters.
-      int status = (result & 0xff) << 8;
-      MOZ_RELEASE_ASSERT(write(REPRL_CWFD, &status, 4) == 4);
+      struct {
+        int status;
+        uint32_t execHash;
+        uint32_t execHashInputs;
+      } s;
+      s.status = (result & 0xff) << 8;
+      s.execHash = cx->executionHash;
+      s.execHashInputs = cx->executionHashInputs;
+      MOZ_RELEASE_ASSERT(write(REPRL_CWFD, &s, 12) == 12);
       __sanitizer_cov_reset_edgeguards();
+      cx->executionHash = 1;
+      cx->executionHashInputs = 0;
     }
 #endif
 
-- 
2.34.1

